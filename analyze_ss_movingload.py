# -*- coding: utf-8 -*-
"""Analyze_ss_movingload

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1u71osJ3n80q-bn-ghoDYEo30FsSOD5Pg
"""

def analyze_beam(L, W1, W2, x):
    """
    Analyze shear force and bending moment for a simply supported beam under moving loads W1 and W2.
    L: Total length of the beam (m)
    W1, W2: Point loads (kN)
    x: distance between W1 and W2 (m)
    """
    dx = 0.1  # step size for moving load simulation
    positions = [i for i in frange(0, L - x, dx)]  # positions of W1

    max_reaction_A = 0
    max_reaction_B = 0
    BM_01 = 0
    SF_01 = 0
    SF_max = float('-inf')
    BM_max = float('-inf')
    SF_max_location = 0
    BM_max_location = 0

    for p in positions:
        # W1 at p, W2 at p + x
        if p + x > L:
            continue

        # Influence line: Reactions at supports
        RA = ((L - p) * W1 + (L - (p + x)) * W2) / L
        RB = (p * W1 + (p + x) * W2) / L

        # Max reaction tracking
        max_reaction_A = max(max_reaction_A, RA)
        max_reaction_B = max(max_reaction_B, RB)

        # Bending moment at A when W1 at 0
        if p == 0:
            BM_01 = W1 * (L - p) * p / L  # W1 at start, moment at A is 0

        # SF when center of load at mid-span
        if abs((p + x / 2) - L / 2) < dx:
            SF_01 = RA  # Shear at center (left of center section)

        # Bending moment at center (z = L/2)
        z = L / 2
        BM = 0
        for load, load_pos in [(W1, p), (W2, p + x)]:
            if load_pos <= z:
                BM += load * (L - load_pos) * load_pos / L
        if BM > BM_max:
            BM_max = BM
            BM_max_location = z

        # Shear force just right of midspan
        SF = RA - (W1 if p <= z else 0) - (W2 if p + x <= z else 0)
        if abs((p + x / 2) - z) < dx and SF > SF_max:
            SF_max = SF
            SF_max_location = z

    # Output results
    print("\n===== Beam Analysis Report =====")
    print(f"Max Reaction at A: {round(max_reaction_A, 2)} kN")
    print(f"Max Reaction at B: {round(max_reaction_B, 2)} kN")
    print(f"BM_01 (W1 at L=0): {round(BM_01, 2)} kNm")
    print(f"SF_01 (center of load at L/2): {round(SF_01, 2)} kN")
    print(f"SF_max: {round(SF_max, 2)} kN at {round(SF_max_location, 2)} m from A")
    print(f"BM_max: {round(BM_max, 2)} kNm at {round(BM_max_location, 2)} m from A")

def frange(start, stop, step):
    """Floating point range generator"""
    while start <= stop:
        yield round(start, 4)
        start += step

# Sample input to test the function
if __name__ == '__main__':
    L = float(input("Enter beam length L (m): "))
    W1 = float(input("Enter load W1 (kN): "))
    W2 = float(input("Enter load W2 (kN): "))
    x = float(input("Enter distance between W1 and W2 (m): "))
    analyze_beam(L, W1, W2, x)

